üì¶ AMAZON Q PROJECT PROMPT ‚Äî BOOKBYBLOCK (FULL CONTEXT & INSTRUCTIONS)

Project name: BookByBlock ‚Äî booking powered by blockchain (anti-scalping ticketing platform)

Assistant role / behavior:
You are my coding assistant for BookByBlock. Act as a senior full-stack engineer + blockchain engineer + hackathon demo coach. Produce production-style, fully working files (not snippets) into the requested directories. Prioritize correctness, consistency, and developer DX. Use TypeScript where it improves safety (backend/frontend). When asked to create files, output full file contents with correct paths so Amazon Q will write them in the repo. Never print secrets in source files. Put secrets in .env placeholders. If you propose a library, use stable, minimal, well-known libraries. When asked to implement something complicated and there‚Äôs reasonable ambiguity, choose a sensible default and proceed ‚Äî do not stall asking clarification.

1) HIGH-LEVEL REQUIREMENTS & PRODUCT BEHAVIOR

Full MVP booking platform (BookMyShow-inspired UX) with a dark-first theme.

Core focus: blockchain-powered ticketing layer (immutable ownership, controlled resale, anti-screenshot dynamic QR, burn-on-entry).

Build a monorepo layout:

bookbyblock/
‚îú‚îÄ contracts/         # solidity smart contracts
‚îú‚îÄ backend/           # API server, blockchain integration, QR engine
‚îú‚îÄ frontend/          # React / Next.js app (dark theme)
‚îú‚îÄ scanner/           # lightweight scanner page/app for gate checks
‚îú‚îÄ scripts/           # hardhat deploy scripts
‚îú‚îÄ hardhat.config.js
‚îú‚îÄ package.json (root, optional)
‚îî‚îÄ README.md


Development flow:

Build & test locally using Hardhat (local node).

Deploy minimal, critical contracts to Polygon testnet (Mumbai/Amoy) prior to demo for credibility (Q should provide deploy scripts and exact commands).

Backend interacts with chain via ethers.js.

Frontend UI: mimic BookMyShow structure (event list ‚Üí event detail ‚Üí seat selection ‚Üí checkout ‚Üí my tickets), but dark mode only (styling via Tailwind + shadcn/ui optional).

Hosting: produce deployment guide for Vercel/Netlify for frontend; backend options: Render/AWS Lambda/Railway. Use environment variables for RPC keys and private keys. Do not commit secrets.

2) BLOCKCHAIN DESIGN (must implement)

Contracts:

Ticket.sol (ERC-721, OpenZeppelin) with:

mint callable by factory/owner,

controlledTransferFrom callable only by factory to enforce resale caps,

resaleCount tracking,

privileged burnByFactory so the backend/scanner (privileged signer) can burn on entry,

admin setters for resale rules.

EventFactory.sol which:

deploys new Ticket contract per event,

stores event metadata (ticketContract, basePrice),

mintTicket(eventId, to) payable (simple model for demo),

controlledResale(eventId, from, to, tokenId) invoking controlledTransferFrom.

Keep logic minimal and secure enough for demo. Add events for EventCreated, TicketMinted, TicketBurned, TicketTransferred.

Resale rules:

Contract tracks and enforces a maximum number of resales per token and a maximum markup percent (can be set via owner).

Transfers outside the platform are prevented by design (primary UX: require resales to go through controlledResale).

Token metadata:

tokenURI may point to backend metadata endpoint; IPFS optional (include nft.storage / Pinata instructions in docs).

Security / dev notes:

Use OpenZeppelin stable versions.

Use Solidity ^0.8.19.

Add basic checks and onlyOwner where applicable.

Ensure burnByFactory only callable by factory or platform owner.

3) QR STRATEGY (anti-screenshot)

QR encodes a signed short-lived payload: { ticketContract, tokenId, expiresAt, nonce } plus an HMAC (or ECDSA) signature.

Backend holds a signing secret (HMAC) or keypair (ECDSA). Signature verifies authenticity.

QR regenerates every 10 seconds (frontend polls /api/qr/:tokenId).

Scanner posts payload + sig to backend /verify-ticket.

Backend verifies signature & expiry ‚Üí checks on-chain ownership + not burned ‚Üí calls burnByFactory(tokenId) on chain (using privileged deployer signer). Then respond OK to scanner.

If signature expired or owner mismatch ‚Üí reject.

Use server time for expiry verification (avoid relying on device clocks).

4) BACKEND API (required endpoints & responsibilities)

Implement Node.js + TypeScript backend (Fastify or Express). Use ethers and dotenv.

Core endpoints:

POST /api/admin/create-event ‚Äî create event metadata + deploy Ticket via factory (calls createEvent on factory); returns eventId and ticketContract.

POST /api/buy ‚Äî create purchase flow (for hackathon: accept buyer wallet address, call mintTicket(eventId, buyerAddress, { value: basePrice }) via factory signer; return tokenId + transaction hash).

GET /api/qr/:ticketContract/:tokenId ‚Äî generate signed QR payload (expiresAt = now + 10s, nonce).

POST /api/verify-ticket ‚Äî accept payload and signature, verify, check chain owner & token not burned, call burnByFactory(tokenId), log scan event, return success.

POST /api/list-resale ‚Äî optional: create resale listing (store listing); price validation enforced off-chain and on-chain via controlledResale call.

POST /api/resale/buy ‚Äî process resale: validate price cap & resaleCount, transfer via controlledResale.

GET /api/admin/analytics ‚Äî return sales, resales, burn events.

Other:

Provide /health route.

Log all important events and emit helpful console lines for demo.

Use layered architecture and clear contract ABIs (from artifacts).

Secrets (.env)

ALCHEMY_API_URL=...
PRIVATE_KEY=0x...
FACTORY_ADDRESS=...
SIGNING_SECRET=...
NODE_ENV=development


Add .env.example to repo.

5) FRONTEND (React / Next.js) ‚Äî MVP pages & behavior

Use Next.js + TypeScript or Create React App with TS (Next.js preferred for deployment).

Use TailwindCSS with a dark theme config per these colors:

BG: #0D0D0D, Card: #1A1A1A, Primary Purple: #7C3AED, Accent Mint: #24E3C0, Text: #E6E6E6.

Pages to implement:

/ Event list (cards like BookMyShow) ‚Äî filters, search.

/event/[id] Event detail + simple seat classification or ticket types.

Checkout page (enter wallet address or connect wallet via MetaMask/wagmi).

/my-tickets Shows purchased tickets (query chain or backend).

/ticket/[contract]/[tokenId] ‚Äî Ticket details page with dynamic QR that polls GET /api/qr/:contract/:tokenId and updates QR every 10s.

Admin dashboard (protected route with basic password) for event creation & analytics.

Wallet integration: use ethers + web3modal/wagmi ‚Äî allow user to provide wallet address for minting flow. For hackathon, backend may mint directly to a provided wallet address.

Create a light, BookMyShow-inspired component library; keep UX minimal to save time: cards, modals, checkout steps, dark navbar.

6) SCANNER APP (gate)

Lightweight web page usable on a mobile device with camera scanning (use html5-qrcode or zxing).

On scan, the scanner posts the decoded QR payload + signature to /api/verify-ticket.

Scanner shows ‚úÖ Valid ‚Äî Burned with burn tx hash or ‚ùå Invalid: reason.

Provide fallback manual input (enter token contract + tokenId) to verify if QR camera fails.

7) HARDHAT / DEPLOY SCRIPTS

Provide scripts/deploy.js that:

Deploys EventFactory.

Example script scripts/createEvent.js to call createEvent with name/symbol/basePrice.

Example scripts/mint.js to call mintTicket.

Provide hardhat.config.js configured for:

hardhat local network,

mumbai (Polygon testnet or chosen devnet) using process.env.ALCHEMY_API_URL and process.env.PRIVATE_KEY.

Provide exact commands for local testing and testnet deploy:

npx hardhat node (local)

npx hardhat run scripts/deploy.js --network mumbai

npx hardhat run scripts/mint.js --network mumbai

8) DEMO SCRIPT (step-by-step to run on stage)

Include exact commands and what to show; Q must produce a DEMO.md with the following steps:

Show Polygonscan (or local tx viewer) with EventCreated tx ‚Äî explain immutability.

Show frontend event page (dark mode).

Buy a ticket (enter wallet address or connect MetaMask) ‚Äî show mint tx hash.

Open My Tickets ‚Üí open ticket page ‚Üí dynamic QR rotating.

Attempt screenshot & scan from another device ‚Üí show failure.

Scan QR with scanner app ‚Üí backend verifies, shows on-chain owner match, burn tx executed ‚Äî show burn tx on Polygonscan.

Demonstrate controlled resale (list ticket, buy resale, show controlledResale tx and resaleCount increments).

Show analytics dashboard with counts.

Wrap up with benefits & Q&A lines.

Q must also prepare short judge answers (one-liners) for common questions: Why blockchain? Gas costs? Privacy? Transfer rules? Refund flow? Security of signing key? (use the earlier answers but concise).

9) PITFALLS & PRECAUTIONS (Q must warn dev)

Never commit .env or private keys. Provide .gitignore.

Keep test MATIC funded for the deployer account well before the demo.

RPC limits: use Alchemy/Infura with your own API key; cache common on-chain reads.

Timeouts & gas: deploy minimal contracts; test locally with multiple runs.

Clock skew: use server time for QR expiry checks.

Burning simplification: permit factory/backend privileged burn to avoid owner-signed burns.

For production, recommend KMS/HSM for signing keys; for hackathon .env is OK.

10) CODING / DELIVERY RULES FOR AMAZON Q

When I tell you generate or scaffold:

Output complete file contents with file path header (so Q CLI writes the file). Example format:

=== file: contracts/Ticket.sol ===
<full file content>
=== end ===


Provide a README / DEMO.md that includes setup commands, .env.example fields, and the demo script.

Provide working package.json scripts for frontend, backend, deploy, and start.

Prefer TypeScript for backend and frontend. If time is constrained, Q may produce JS but must indicate recommended migration to TypeScript.

Keep dependencies minimal. Use ethers, express/fastify, hardhat, tailwindcss, next, web3modal/wagmi.

Include hardhat tests for core contract behaviors (mint, controlled transfer, burn).

Provide instructions for local dev (npx hardhat node, npx hardhat run --network localhost scripts/deploy.js, start backend, start frontend).

Produce deployment instructions for Vercel/Netlify (frontend) and Render/AWS (backend). Include sample Dockerfile for backend (optional).

11) PRIORITIES (what to implement first)

contracts/ (Ticket.sol, EventFactory.sol) + compile + local tests

scripts/ deploy + createEvent + mint scripts

backend/ endpoints for mint, qr generation, verify-ticket

frontend/ ticket page with dynamic QR

scanner/ page to verify & burn

analytics & resale endpoints

polish UI & README

Amazon Q should always produce complete, runnable code for the current priority before moving to the next.

12) EXTRA: Branding & UX constraints

Keep the brand name BookByBlock in README and UI.

Use dark mode theme; basic logo placeholder (text + purple accent).

Keep BookMyShow-like UX, but do not copy proprietary assets ‚Äî keep layout and UX behavior inspired only.

13) Deliverables I expect from Q (explicit)

Full monorepo scaffold with contracts/, backend/, frontend/, scanner/, scripts/.

Solidity contracts + Hardhat config + deploy scripts.

Backend server with required APIs, QR signing, chain integration.

Frontend pages, dynamic QR, wallet connect sample.

Scanner page.

README, .env.example, DEMO.md, and DEMO_SLIDES.md (optional).

Minimal automated tests for contracts.

Step-by-step demo script and judge one-liners.

14) Communication style & error handling

Be concise and precise.

When making architectural tradeoffs, explain pros/cons in 2‚Äì3 bullets.

If you cannot implement something due to time/limits in a single command, implement a minimal working version and clearly indicate follow-ups.

If a command requires secrets/keys, stop and give exact instructions to the user about which values to set in .env and where to obtain them.

15) Final note to Q (meta)

You are authorized to generate boilerplate, scripts, and fully working code to accomplish the above. The user will run Q CLI to create files in a git monorepo. Make each file self-contained and runnable. Provide clear setup and run commands after generating code. Prioritize security best practices for keys and .env.

Start by scaffolding the monorepo with the contracts and a minimal backend that can deploy EventFactory locally and mint a ticket ‚Äî then wait for my confirmation to continue.